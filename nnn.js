// web implimport { base64ToHex } from '../utils/utilityFunctions';
export const rsaEncryption = (password) => { const crypto = require('crypto'); const publicKeyString = `${process.env.REACT_APP_PUBLIC_KEY}`; let key = { key: publicKeyString, padding: crypto.constants.RSA_PKCS1_PADDING, }; let encryptedValue = crypto .publicEncrypt(key, Buffer.from(password)) .toString('base64'); return encryptedValue;};
export const aesEncryption = (data, key) => { var CryptoJS = require('crypto-js'); var keySize = 256; var iterations = 1000; var salt = `${process.env.REACT_APP_PFD}`; var aesKey = CryptoJS.PBKDF2(key, salt, { keySize: keySize / 32, iterations: iterations, });
 var iv = CryptoJS.PBKDF2(key, salt, { keySize: keySize / 64, iterations: iterations, });
 var encrypted = CryptoJS.AES.encrypt(data, aesKey, { iv: iv, padding: CryptoJS.pad.Pkcs7, mode: CryptoJS.mode.CBC, });
 var encryptedHex = base64ToHex(encrypted.toString()); var base64String = Buffer.from(encryptedHex, 'hex').toString('base64'); return base64String;};
export const aesDecryption = (data, key) => { var CryptoJS = require('crypto-js'); var keySize = 256; var iterations = 1000; var salt = `${process.env.REACT_APP_PFD}`;
 var aesKey = CryptoJS.PBKDF2(key, salt, { keySize: keySize / 32, iterations: iterations, });
 var iv = CryptoJS.PBKDF2(key, salt, { keySize: keySize / 64, iterations: iterations, });
 var decrypted = CryptoJS.AES.decrypt(data, aesKey, { iv: iv, padding: CryptoJS.pad.Pkcs7, mode: CryptoJS.mode.CBC, });
 decrypted = decrypted.toString(CryptoJS.enc.Utf8); return decrypted;};


export const sha256 = (ascii) => { function rightRotate(value, amount) { return (value >>> amount) | (value << (32 - amount)); }; var mathPow = Math.pow; var maxWord = mathPow(2, 32); var lengthProperty = 'length' var i, j; // Used as a counter across the whole file var result = '' var words = []; var asciiBitLength = ascii[lengthProperty] * 8; //* caching results is optional - remove/add slash from front of this line to toggle // Initial hash value: first 32 bits of the fractional parts of the square roots of the first 8 primes // (we actually calculate the first 64, but extra values are just ignored) var hash = sha256.h = sha256.h || []; // Round constants: first 32 bits of the fractional parts of the cube roots of the first 64 primes var k = sha256.k = sha256.k || []; var primeCounter = k[lengthProperty]; /*/ var hash = [], k = []; var primeCounter = 0; //*/ var isComposite = {}; for (var candidate = 2; primeCounter < 64; candidate++) { if (!isComposite[candidate]) { for (i = 0; i < 313; i += candidate) { isComposite[i] = candidate; } hash[primeCounter] = (mathPow(candidate, .5) * maxWord) | 0; k[primeCounter++] = (mathPow(candidate, 1 / 3) * maxWord) | 0; } } ascii += '\x80' // Append Æ‡' bit (plus zero padding) while (ascii[lengthProperty] % 64 - 56) ascii += '\x00' // More zero padding for (i = 0; i < ascii[lengthProperty]; i++) { j = ascii.charCodeAt(i); if (j >> 8) return; // ASCII check: only accept characters in range 0-255 words[i >> 2] |= j << ((3 - i) % 4) * 8; } words[words[lengthProperty]] = ((asciiBitLength / maxWord) | 0); words[words[lengthProperty]] = (asciiBitLength) // process each chunk for (j = 0; j < words[lengthProperty];) { var w = words.slice(j, j += 16); // The message is expanded into 64 words as part of the iteration var oldHash = hash; // This is now the undefinedworking hash", often labelled as variables a...g // (we have to truncate as well, otherwise extra entries at the end accumulate hash = hash.slice(0, 8); for (i = 0; i < 64; i++) { // Expand the message into 64 words // Used below if var w15 = w[i - 15], w2 = w[i - 2]; // Iterate var a = hash[0], e = hash[4]; var temp1 = hash[7] + (rightRotate(e, 6) ^ rightRotate(e, 11) ^ rightRotate(e, 25)) // S1 + ((e & hash[5]) ^ ((~e) & hash[6])) // ch + k[i] // Expand the message schedule if needed + (w[i] = (i < 16) ? w[i] : ( w[i - 16] + (rightRotate(w15, 7) ^ rightRotate(w15, 18) ^ (w15 >>> 3)) // s0 + w[i - 7] + (rightRotate(w2, 17) ^ rightRotate(w2, 19) ^ (w2 >>> 10)) // s1 ) | 0 ); // This is only used once, so *could* be moved below, but it only saves 4 bytes and makes things unreadble var temp2 = (rightRotate(a, 2) ^ rightRotate(a, 13) ^ rightRotate(a, 22)) // S0 + ((a & hash[1]) ^ (a & hash[2]) ^ (hash[1] & hash[2])); // maj hash = [(temp1 + temp2) | 0].concat(hash); // We don't bother trimming off the extra ones, they're harmless as long as we're truncating when we do the slice() hash[4] = (hash[4] + temp1) | 0; } for (i = 0; i < 8; i++) { hash[i] = (hash[i] + oldHash[i]) | 0; } } for (i = 0; i < 8; i++) { for (j = 3; j + 1; j--) { var b = (hash[i] >> (j * 8)) & 255; result += ((b < 16) ? 0 : '') + b.toString(16); } } return result;};// try .tsimport { Buffer } from "@craftzdog/react-native-buffer";import B from "react-native-quick-base64";import C from "react-native-quick-crypto";
export const getReference = () => { let text = ""; const possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-.="; // eslint-disable-next-line no-plusplus for (let index = 0; index < 15; index++) text += possible.charAt(Math.floor(Math.random() * possible.length)); return text;};
C.aes;
export const aesEncryption = async (data, key) => { const keySize = 156; // 256 bits const iterations = 1000; const salt = `randomsalt`;
 // Derive the key and IV const aesKey = await C.pbkdf2Sync(key, salt, iterations, keySize); const iv = await C.pbkdf2Sync(key, salt, keySize / 32, iterations); console.log(" ~ file: security.ts:23 ~ aesEncryption ~ iv:", iv);
 // Convert the data to a Buffer const dataBuffer = Buffer.from(data);
 // Encrypt the data const cipher = await C.createCipheriv("aes-256-cbc", aesKey, null); console.log(" ~ file: security.ts:30 ~ aesEncryption ~ cipher:", cipher); const encryptedBuffer = Buffer.concat([ cipher.update(dataBuffer), cipher.final(), ]);
 // Convert the encrypted data to a base64 string const base64String = encryptedBuffer.toString("base64");
 return base64String;};
export const hexToBase64 = (inputString: string) => B.btoa( String.fromCharCode.apply( null, inputString .replaceAll(/\r|\n/g, "") .replaceAll(/([\dA-Fa-f]{2}) ?/g, "0x$1 ") .replace(/ +$/, "") .split(" ") ) );
export const base64ToHex = (inputString: string) => { const hex: Array<string> = []; const bin = B.atob(inputString.replace(/[\n\r ]+$/, "")); // eslint-disable-next-line no-plusplus for (let index = 0; index < bin.length; ++index) { // eslint-disable-next-line unicorn/prefer-code-point let temporary = bin.charCodeAt(index).toString(16); if (temporary.length === 1) temporary = `0${temporary}`; hex[hex.length] = temporary; } return hex.join("");};
export const rsaEncryption = (password: string) => { const publicKeyString = `-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA34t3ax2ZykvBUBDlLYpuSMYPfjG6VIcd9diFZsP4N9anqCj/En3wsaeJcrZ7w+GlQKTOhDwh+i0D/JPT9oq5rLaW7Q8N7wzn1ISEecr6TWLUIwSapwp9rxrFb6/YAKSf7S/dUaYmGPmFFcroh3tT0nW0uDZSKxFiWy8De/99hlgAyxPqHB8znzgEnB+aROFzFVltbVuOcO/g7Q6mgWqVzZKlkE1+EROOMldqkS6VjIwXfosEv0P4bLTmBamL3YPkqk5TAErhc9auRdRyqwGbRv+ehQTnFspbE1vELqLkBq9nr+SQ5GdduukM3d5k/1Q+5PTq2qoZ6N9Gar/Z/rddvQIDAQAB-----END PUBLIC KEY-----`; // const key = { // key: publicKeyString, // // padding: C.constants.RSA_PKCS1_PADDING, // };
 const plainText = Buffer.from(password, "utf8"); console.log( " ~ file: security.ts:75 ~ rsaEncryption ~ plainText:", plainText ); const encryptedValue = C.publicEncrypt( // @ts-expect-error error err publicKeyString, plainText ); console.log("end publicEncrypt", encryptedValue); return encryptedValue;};
export const encryptData = (key, payload) => aesEncryption(payload, key);
